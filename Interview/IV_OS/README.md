## 목차

- [1. 🎤 운영체제 기초](#-운영체제-기초)
- [2. 🎤 메모리 계층구조](#-메모리-계층구조)
- [3. 🎤 프로세스와 스레드 & 멀티프로세스와 멀티스레딩](#-프로세스와-스레드--멀티프로세스와-멀티스레딩)
- [4. 🎤 CPU 스케줄링 알고리즘](#-cpu-스케줄링-알고리즘)
- [5. 🎤 인터럽트(Interrupt)](#-인터럽트interrupt)
- [6. 🎤 시스템 콜(System Call)](#-시스템-콜system-call)
- [7. 🎤 PCB & Context Switching](#-pcb--context-switching)
- [8. 🎤 주소 공간과 변환 & 가상 메모리(Address Space, Virtual Memory)](#-주소-공간과-변환--가상-메모리address-space-virtual-memory)
- [9. 🎤 세그먼테이션(Segmentation)](#-세그먼테이션segmentation)
- [10. 🎤 페이징(Paging)](#-페이징paging)
- [11. 🎤 가상메모리와 요구 페이징 & 페이지 교체](#-가상메모리와-요구-페이징--페이지-교체)
- [12. 🎤 Paging : Smaller Table](#-paging--smaller-table)
- [13. 🎤 TLB(Translation Lookaside Buffers)](#-tlbtranslation-lookaside-buffers)
- [14. 🎤 동기화(스핀락, 세마포어, 뮤텍스)](#-동기화스핀락-세마포어-뮤텍스)
- [15. 🎤 교착상태(DeadLock)](#-교착상태deadlock) <br/><br/>

## <span style="color: #FFA500">**🎤 운영체제 기초**</span>

**Q. 운영체제는 무엇일까요?**

A. 운영체제는 컴퓨터 하드웨어와 사용자 간의 인터페이스 역할을 하고 시스템의 메모리 관리, 파일 시스템 관리, 입출력 장치 관리, 프로세스 관리 등 다양한 기능을 수행합니다. <br/><br/>

**Q. CPU는 무엇일까요?**

A. CPU는 모든 계산, 명령 실행, 데이터 처리 등의 중요한 작업을 담당합니다. <br/><br/>

## <span style="color: #FFA500">**🎤 메모리 계층구조**</span>

**Q. 캐시 ( Cache ) 메모리를 왜 사용하나요?**

A. CPU와 메모리 사이의 속도 차이를 완화하기 위해 사용합니다.

캐시(cache)는 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다. 이를 통해 데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 무언가를 다시 계산하는 시간을 절약할 수 있다. <br/><br/>

**Q. 메모리의 종류를 말하고 종류가 여러가지인 이유에 대해 설명해주세요.** 

A. CPU에 가까운 순서대로 레지스터, 캐시, 주기억장치, 보조기억장치가 있습니다. 

종류가 여러가지인 이유는 레지스터, 캐시와 같은 고속 메모리는 제작 비용이 높은 반면, 보조기억장치는 비용이 상대적으로 저렴합니다. 다양한 종류의 메모리를 사용하여 비용과 성능 사이의 최적의 균형을 찾습니다. <br/><br/>

## <span style="color: #FFA500">**🎤 프로세스와 스레드 & 멀티프로세스와 멀티스레딩**</span>

**Q. 프로세스와 스레드의 정의에 대해 설명해주세요.**

**프로세스 (Process)**:
프로세스는 실행 중인 프로그램을 의미합니다. 운영체제에서 할당되는 독립적인 실행 단위로, 자체적인 메모리 공간을 가지고 있습니다. 프로세스는 코드, 데이터, 힙, 스택 영역으로 구성됩니다. 각 프로세스는 서로 독립적이며, 한 프로세스의 메모리는 다른 프로세스와 공유되지 않습니다. 프로세스는 운영체제에 의해 생성, 관리, 종료됩니다. <br/><br/>

**스레드 (Thread)**:
스레드는 프로세스 내에서 실행되는 작업의 단위입니다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 이 스레드들은 프로세스의 메모리 공간(코드, 데이터, 힙)을 공유합니다. 각 스레드는 독립적인 실행 흐름을 가지고 있으며, 자신의 스택을 가집니다. 스레드는 프로세스보다 더 가벼운 실행 단위로, 스레드 간의 문맥 전환이 프로세스 간의 문맥 전환보다 빠릅니다. <br/><br/>

**Q.  프로세스와 스레드에 대한 차이에 대해 설명해주세요.**

1. **메모리 구조**:
    - 프로세스는 독립적인 메모리 공간을 가집니다. 각 프로세스는 자신만의 코드, 데이터, 힙, 스택을 가지고 있습니다.
    - 스레드는 같은 프로세스 내에서 메모리 공간을 공유합니다. 스레드들은 코드, 데이터, 힙을 공유하지만, 각자의 스택을 가집니다.
2. **자원 할당**:
    - 프로세스는 운영체제로부터 독립적인 자원을 할당받습니다. 새로운 프로세스 생성 시, 새로운 메모리 공간이 필요합니다.
    - 스레드는 동일한 프로세스 내에서 자원을 공유하기 때문에 새로운 스레드 생성 시 추가적인 메모리 할당이 적습니다.
3. **문맥 전환**:
    - 프로세스 간 문맥 전환은 무겁고 비용이 많이 듭니다. 각 프로세스는 독립적인 메모리 공간을 가지므로 문맥 전환 시 메모리 맵의 전환이 필요합니다.
    - 스레드 간 문맥 전환은 상대적으로 가볍습니다. 같은 메모리 공간을 공유하므로 스택 포인터와 레지스터 등의 전환만 필요합니다.
4. **독립성**:
    - **프로세스는 독립적입니다. 한 프로세스가 중단되더라도 다른 프로세스에 영향을 미치지 않습니다.**
    - **스레드는 같은 프로세스 내에서 동작하기 때문에, 한 스레드가 중단되면 다른 스레드에도 영향을 미칠 수 있습니다.** <br/><br/>

**Q. 멀티 프로세스와 멀티 스레드의 특징에 대해 설명해주세요.**

**멀티 프로세스 (Multi-process)**:

- **장점**:
    - 안정성: 하나의 프로세스가 실패해도 다른 프로세스에 영향을 주지 않습니다.
    - 독립성: 각 프로세스는 독립적으로 실행되므로 충돌이나 자원 공유 문제를 줄일 수 있습니다.
    - 병렬성: 여러 프로세스가 동시에 실행되어 성능을 향상시킬 수 있습니다.
- **단점**:
    - 자원 소모: 각 프로세스가 독립적인 메모리 공간을 필요로 하므로 메모리 사용량이 많아질 수 있습니다.
    - 문맥 전환 비용: 프로세스 간 문맥 전환은 비용이 많이 들고 성능 저하를 초래할 수 있습니다. <br/><br/>

**멀티 스레드 (Multi-thread)**:

- **장점**:
    - 자원 효율성: 스레드 간 메모리 공유로 인해 메모리 사용량이 적습니다.
    - 빠른 문맥 전환: 스레드 간 문맥 전환은 가볍고 빠릅니다.
    - 성능 향상: 동시에 여러 작업을 수행함으로써 응답성을 높일 수 있습니다.
- **단점**:
    - 동기화 문제: 여러 스레드가 같은 자원에 접근할 때 동기화 문제로 인한 버그나 성능 저하가 발생할 수 있습니다.
    - 안정성: 한 스레드의 문제가 전체 프로세스에 영향을 줄 수 있습니다. <br/><br/>

## <span style="color: #FFA500">**🎤 CPU 스케줄링 알고리즘**</span>

**Q. CPU Scheduling은 무엇이고 종류는 무엇이 있는지 설명해주세요.**

A. CPU 하나는 동시에 여러개의 프로세스를 처리할 수 없기 때문에, 한 순간에 어떤 프로세스가 CPU를 사용할 수 있게 하는지 결정하는 정책이다. 종류로는 선입 선처리 스케줄링, 최단 작업 우선 스케줄링, 라운드 로빈 스케줄링, 최소 잔여 시간 우선 스케줄링, 우선순위 스케줄링, 다단계 큐 스케줄링, 다단계 피드백 큐 스케줄링 등이 있다. <br/><br/>

**Q. 선점형 스케줄링과 비선점형 스케줄링의 차이를 설명해주세요.**

A. 선점형 스케줄링은 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당하는 스케줄링 방식을 말한다. 반면 비선점형 스케줄링은 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식을 말한다. <br/><br/>

+) 각각의 장단점?
선점형 스케줄링은 더 급한 프로세스가 언제든 끼어들어 사용할 수 있는 스케줄링 방식이므로 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다는 장점이 있지만, 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다. 반면 비선점형 스케줄링은 문맥 교환의 횟수가 선점형 스케줄링보다 적기 때문에 문맥 ㄹ교환에서 발생하는 오버헤드도 적지만, 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 기다리는 수밖에 없다. 즉, 모든 프로세스가 골고루 자원을 사용할 수 없다는 단점이 있다. <br/><br/>

**Q. 콘보이 현상(convoy effect)이란 무엇이고, 콘보이 현상이 발생될 수 있는 CPU 스케줄러 알고리즘은 무엇인지 설명해주세요.**

A. 콘보이 현상이란 작업 시간이 긴 프로세스가 먼저 큐에 도착해서 다른 프로세스의 실행 시간이 전부 늦춰져 효율성을 떨어뜨리는 현상을 말한다. FCFS(First-Come First Served) 스케줄링은 비선점형으로, 순차적으로 먼저 큐에 들어온 작업부터 실행하므로 콘보이 현상이 발생할 수 있다. <br/><br/>

## <span style="color: #FFA500">**🎤 인터럽트(Interrupt)**</span>

**Q. 인터럽트에 대해서 설명해주세요.**

A. 인터럽트는 컴퓨터에서 실행 중인 프로그램의 흐름을 일시적으로 중지시키고, 특정 작업(ISR)을 수행한 뒤 원래의 작업으로 돌아가게 하는 메커니즘이다. <br/><br/>

**Q. 인터럽트 발생 처리 과정에 대해서 설명해주세요.**

1. 주 프로그램 작업 수행 중 인터럽트 발생
2. 주 프로그램 상태 레지스터와 PC 등을 스택에 잠시 저장(나중에 주 프로그램으로 복귀할 때 복원하기 위함)
3. ISR로 인터럽트 처리
4. 다시 주 프로그램 작업 복귀 <br/><br/>

**Q.  인터럽트와 폴링의 차이에 대해서 설명해주세요.**

A. Polling이란 CPU가 작업을 진행하다 입출력 명령을 만나면 직접 입출력 장치에서 데이터를 가져오는 방식이다. CPU가 직접 일을 하기 때문에 입출력을 하는 동안 다른 일을 하지 못한다. 따라서 입출력이 처리되는 동안 기다려야하는데 시간이 오래 걸리며 작업 효율이 떨어져 현재는 사용하지 않는다. 

폴링은 CPU 관점에서는 입출력 명령이 언제 완료될 지 알 수 없기 때문에 주기적으로 계속 확인을 해줘야한다. 단점 : 주기적으로 CPU가 확인해야하니 CPU 성능 ▽, 단점을 해결한 것이 인터럽트다. <br/><br/>

## <span style="color: #FFA500">**🎤 시스템 콜(System Call)**</span>

**Q. 시스템 콜이 무엇인가요?**

A. **운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스**

프로그램이 OS 커널이 제공하는 서비스를 이용하고 싶을 때 시스템 콜을 통해 실행합니다.

시스템 콜은 커널 영역의 기능을 사용자 모드가 가용 가능하게, 즉 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 할 수 있게 해줍니다. <br/><br/>

**Q. 운영 체제의 dual mode (사용자 모드 / 커널 모드) 에 대해 설명해주세요. 각각 무엇이고, 둘로 나누어야 하는 이유가 뭔가요?**

**시스템을 보호하기 위해!**
우리가 개발한 프로그램은 시스템 기능이나 HW에 접근하려면 커널을 통해서 접근할 수 있게 설정함으로써 시스템이 안정적으로 동작할 수 있도록 합니다.

사용자 process는 User Mode에서 실행되다가 시스템 자원을 사용해야할 때 시스템 콜을 호출해서 커널 모드로 전환되어 작업을 수행하고 완료 시 다시 사용자 모드로 전환합니다. <br/><br/>

**Q.  시스템 콜이 운영 체제에서 어떻게 동작하는지 과정을 설명해주세요 ( 30-40 sec 이내로 간단하게 ~ )**

(1) 사용자 프로세스가 시스템 콜 호출 (커널 모드 진입)
(2) 커널은 내부적으로 시스템 콜을 구분하기 위해 기능 별로 고유 번호를 할당하고 그 번호에 해당하는 제어 루틴을 정의
(3) 커널은 요청받은 시스템 콜에 대응하는 고유 번호 확인하고 번호에 맞는 서비스 루틴 호출
(4) 커널은 서비스 루틴을 처리하고 사용자 모드로 전환 <br/><br/>

**Q. 시스템 콜의 종류 5개 - 각각의 예시 1개씩**

A. **프로세스 컨트롤, 파일 매니지먼트, 디바이스 매니지먼트, 통신, 보안** <br/><br/>

## <span style="color: #FFA500">**🎤 PCB & Context Switching**</span>

**Q. PCB란 무엇이고, 프로그램이 실행되었을 때 프로세스가 생성되어 PCB에 저장되는 동작 과정에 대해 설명해주세요.**

A. 프로세스 제어 블록(Process Control Block, 줄여서 PCB)은 프로세스를 관리하기 위한 정보를 포함하는 OS 커널의 자료 구조이다.

프로그램이 실행되어 메모리에 적재됐을 때 **프로세스가 생겨나고, 프로세스 주소 공간에 코드&데이터&스택 공간이 생성**된다. 이후 **해당 프로세스의 메타데이터들이 PCB 에 저장된다.** <br/><br/>

**Q. Context Switching이란 무엇이고, 언제 발생하는지 설명해주세요.**

A. 문맥교환(context switching)은, 여러 프로세스를 처리해야 하는 상황에서 현재 진행중인 Task(프로세스 혹은 쓰레드)의 상태를 PCB에 저장하고, 다음에 진행할 Task의 상태 값을 읽어 레지스터에 적재하는 과정을 의미한다. 

작업을 처리하던 도중 프로세스의 시간이 모두 경과되거나 인터럽트가 발생하는 등의 프로세스 전환이 발생하면 문맥교환이 일어나게 된다. <br/><br/>

**Q. Context Switching의 필요성에 대해 설명해주세요.**

A. CPU Cycle의 속도는 I/O 작업에 비해 빠른데 이 경우 I/O 작업이 실행되고 Blocking된다면 CPU는 아무런 일을 하지 않고 계속 쉬게 되는 것이다. 이때 컨텍스트 스위칭을 통해 다른 프로세스나 쓰레드의 작업으로 전환한다면, CPU의 사용률을 높일 수 있다. 이렇게 효율적으로 CPU를 사용하기 위해서 필요하다. <br/><br/>

## <span style="color: #FFA500">**🎤 주소 공간과 변환 & 가상 메모리(Address Space, Virtual Memory)**</span>

**Q. 메모리 가상화의 목적은 무엇인가요?**

A. 물리적 메모리 한계를 뛰어넘기 위해, 가상화를 통해 시간과 공간 측면에서 효율적이도록 진행 <br/><br/>

**Q. 주소 변환이 무엇인가요?**

A. Virtual Memory를 Physical Memory로 변환하는 과정 <br/><br/>

## <span style="color: #FFA500">**🎤 세그먼테이션(Segmentation)**</span>

**Q. 페이징은 프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당하는 것을 의미한다. 그렇다면 세그멘테이션의 정의는?**

A. 세그멘테이션은 프로세스를 같은 역할을 하는 논리적인 단위를 기반으로 나눠서 메모리에 배치하는 것을 의미한다. <br/><br/>

**Q. 세그멘테이션을 사용하는 이유는?**

A. 메모리 단편화를 해결하기 위해 <br/><br/>

**Q. 세그멘테이션에서 발생하는 단편화의 종류와 정의에 대해서 말씀해주세여**

A. 외부 단편화가 발생하며 외부 단편화는 할당되지 않은 메모리 공간이 충분히 있지만, 연속적인 공간이 아니어서 큰 메모리 요청을 충족시키지 못하는 현상 <br/><br/>

## <span style="color: #FFA500">**🎤 페이징(Paging)**</span>

**Q. 페이징 기법에서 문제점은 무엇인가요?**

A. 내부 단편화, 프로세스의 논리 주소 공간을 페이지라는 일정한 크기 단위로 자른다. 하지만 모든 프로세스가 페이지 크기에 딱 맞게 잘리지 않는다. <br/><br/>

**Q. 페이징(Paging)은 무엇인가요?**

A. 페이징은 `프로세스의 논리 주소 공간`을 `페이지`라는 일정한 단위로 자르고, `메모리 물리 주소 공간`을 `프레임`이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상메모리 관리 기법. <br/><br/>

**Q. 페이지 테이블은 무엇인가요?**

A. 프로세스가 물리주소에 불연속적으로 배치되더라도 논리 주소에는 연속적으로 배치되도록 도와주는 테이블 <br/><br/>

## <span style="color: #FFA500">**🎤 가상메모리와 요구 페이징 & 페이지 교체**</span>

**Q. 페이지 폴트란 무엇인가요**

A. 해당 페이지가 현재 메모리에 없을 경우 페이지 폴트라고 한다. <br/><br/>

**Q. 페이지 교체 알고리즘에 대해 설명해주세요.**

A. 페이지 폴트를 가장 적게 일으키는 알고리즘 <br/><br/>

**Q. 스래싱이란 무엇이고 그 해결방법은 무엇인지 설명해주세요**

A. CPU를 이용하지 못하고 페이지를 계속해서 교체하여 성능이 저해되는 상황을 스래싱이라고 한다. 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문이다. 따라서 운영체제는 각 프로세스들이 실행되기에 무리가 없는 최소한의 프레임 수를 파악하고 할당하는 것이 중요하다. <br/><br/>

## <span style="color: #FFA500">**🎤 Paging : Smaller Table**</span>

**Q. 역페이지 테이블 기법이 무엇인가요? (정의+장점)**

A. 페이지 테이블을 물리적인 메모리 주소 공간에 대응시킨 값으로 구성한 테이블

장점 : page table 크기를 획기적으로 줄일 수 있다. <br/><br/>

**Q. 멀티 레벨 페이징 기법이 무엇인가요? (정의+장점)**

A. 논리 주소 공간을 여러 단계의 page table로 나눔 <br/><br/>

## <span style="color: #FFA500">**🎤 TLB(Translation Lookaside Buffers)**</span>

**Q. TLB란 무엇인지 설명해주세요.**

A. 가상 주소를 물리적 주소로 변환하는 과정에서 사용되는 고속 메모리 하드웨어 <br/><br/>

## <span style="color: #FFA500">**🎤 동기화(스핀락, 세마포어, 뮤텍스)**</span>

**Q. 상호배제란 무엇인가?**

A. 한 프로세스가 공용 데이터를 사용하고 있으면 그 자원을 사용하지 못하도록 막거나, 다른 프로세스가 그 자원을 사용하지 못하도록 막는 것 <br/><br/>

**Q. 스핀락과 뮤텍스의 차이점**

- 스핀락은 프로세스가 락을 획득하지 못하면 프로세스는 다른 일(스케줄링)을 하지 않고 화장실 밖에서 계속 기다림. 무한루프를 돌며 스피닝(락을 얻으려고 시도하는 과정)
- 프로세스가 뮤텍스를 획득하지 못하면 화장실의 문제 자신의 이름을 써 놓고 휴먼 상태로 진입. <br/><br/>

**Q. 세마포어와 뮤텍스의 차이점**

A. 뮤텍스는 세마포어로서 사용될 수 없지만, 세마포어는 뮤텍스로서 사용할 수 있다. <br/><br/>

## <span style="color: #FFA500">**🎤 교착상태(DeadLock)**</span>

**Q. DeadLock의 발생조건은?**

A. 

- 상호 배제(Mutual Exclusion)
    
    > 하나의 Process만이 자원을 사용할 수 있다.
- 비선점(No Preemption)
    
    > 이미 할당된 자원을 강제로 뺏을 수 없다.
- 점유 대기(Hold and Wait)
    
    > 다른 자원을 기다릴 때 보유한 자원을 계속 가지고 있는다.
- 순환 대기(Circular Wait)
    
    > 자원을 기다리는 프로세스 간 사이클이 형성 되어 있어야 한다. 

<br/><br/>

**Q. 은행원 알고리즘의 장점과 단점은?**

A. 

| - 다중 자원 관리 | - 계산 복잡성 |
| --- | --- |
| - 안전 상태 보장 | - 시스템 성능 저하 가능성 |
| - 유연성 | - 정보 요구 (모든 프로세스의 최대 자원 요구량 필요) |
